<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eDSP: edsp::ring_buffer&lt; T, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eDSP
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">A cross-platform DSP library written in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d7/daa/namespaceedsp.html">edsp</a></li><li class="navelem"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d5/dae/classedsp_1_1ring__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">edsp::ring_buffer&lt; T, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a ring buffer, also called circular buffer.  
 <a href="../../d1/d1f/classedsp_1_1ring__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d3/dcf/ring__buffer_8hpp_source.html">ring_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2523b1d2013263f0f589d5f1220ce01d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2523b1d2013263f0f589d5f1220ce01d">self_type</a></td></tr>
<tr class="separator:a2523b1d2013263f0f589d5f1220ce01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50952d1ad4089381fdf10144bb3596ec"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a></td></tr>
<tr class="separator:a50952d1ad4089381fdf10144bb3596ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4de351caca02e8c1d6ddc45e7a8bc7c"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aa4de351caca02e8c1d6ddc45e7a8bc7c">pointer</a></td></tr>
<tr class="separator:aa4de351caca02e8c1d6ddc45e7a8bc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44087c46078636ab5ee16595b457e786"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a44087c46078636ab5ee16595b457e786">const_pointer</a></td></tr>
<tr class="separator:a44087c46078636ab5ee16595b457e786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760fd3853f380e85672538d23a8a87ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a></td></tr>
<tr class="separator:a760fd3853f380e85672538d23a8a87ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b016c118ea98b53a8eafd0a7855d0ee"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a></td></tr>
<tr class="separator:a7b016c118ea98b53a8eafd0a7855d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2312e1d4e8f22847b27eeac8e5cba407"><td class="memItemLeft" align="right" valign="top">typedef ring_buffer_iterator&lt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2523b1d2013263f0f589d5f1220ce01d">self_type</a>, <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">self_type::value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a></td></tr>
<tr class="separator:a2312e1d4e8f22847b27eeac8e5cba407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f1bee8a818f2725943f6b364c0098b"><td class="memItemLeft" align="right" valign="top">typedef ring_buffer_iterator&lt; const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2523b1d2013263f0f589d5f1220ce01d">self_type</a>, const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">self_type::value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a></td></tr>
<tr class="separator:ab6f1bee8a818f2725943f6b364c0098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716804d010b751e34cf81d0ed50add90"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a></td></tr>
<tr class="separator:a716804d010b751e34cf81d0ed50add90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec1e0e45087ccf97ff5e0841145dd5f"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a0ec1e0e45087ccf97ff5e0841145dd5f">difference_type</a></td></tr>
<tr class="separator:a0ec1e0e45087ccf97ff5e0841145dd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cedf5ca13879c92db08307f88d990d"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a93cedf5ca13879c92db08307f88d990d">reverse_iterator</a></td></tr>
<tr class="separator:a93cedf5ca13879c92db08307f88d990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcac877a56b406de8f1ad652ac7e804"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a></td></tr>
<tr class="separator:a8bcac877a56b406de8f1ad652ac7e804"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7e9b02afa103ec956e0763920f24431"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab7e9b02afa103ec956e0763920f24431">ring_buffer</a> ()=default</td></tr>
<tr class="separator:ab7e9b02afa103ec956e0763920f24431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b1a22304e17f6f4a0fe6707ae2285d"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a56b1a22304e17f6f4a0fe6707ae2285d">ring_buffer</a> (const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> &amp;)=default</td></tr>
<tr class="separator:a56b1a22304e17f6f4a0fe6707ae2285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589a0bb51b1d1c64e8bfb0f0698e28ad"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a589a0bb51b1d1c64e8bfb0f0698e28ad">ring_buffer</a> (<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a589a0bb51b1d1c64e8bfb0f0698e28ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a67fe13baebbee4789aed21c295a0f2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a1a67fe13baebbee4789aed21c295a0f2">operator=</a> (const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> &amp;)=default</td></tr>
<tr class="separator:a1a67fe13baebbee4789aed21c295a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee88163fd7cd1b6c8fbcedd43a2913b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a1ee88163fd7cd1b6c8fbcedd43a2913b">operator=</a> (<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a1ee88163fd7cd1b6c8fbcedd43a2913b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499ca20b37cffd8dc7a844e0753ea46a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a499ca20b37cffd8dc7a844e0753ea46a">ring_buffer</a> (<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a> N)</td></tr>
<tr class="memdesc:a499ca20b37cffd8dc7a844e0753ea46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ring_buffer with default constructed elements.  <a href="#a499ca20b37cffd8dc7a844e0753ea46a">More...</a><br /></td></tr>
<tr class="separator:a499ca20b37cffd8dc7a844e0753ea46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdbdf5cd8b357cb931cdb770a2c8bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a51fdbdf5cd8b357cb931cdb770a2c8bf">ring_buffer</a> (<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a> N, const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a51fdbdf5cd8b357cb931cdb770a2c8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ring_buffer with copies of an exemplar element.  <a href="#a51fdbdf5cd8b357cb931cdb770a2c8bf">More...</a><br /></td></tr>
<tr class="separator:a51fdbdf5cd8b357cb931cdb770a2c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b8e0388bebf488edb3514809063cc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#af6b8e0388bebf488edb3514809063cc7">~ring_buffer</a> ()=default</td></tr>
<tr class="memdesc:af6b8e0388bebf488edb3514809063cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.  <a href="#af6b8e0388bebf488edb3514809063cc7">More...</a><br /></td></tr>
<tr class="separator:af6b8e0388bebf488edb3514809063cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cff9f4e0f694f97a271ea56f48ae7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2cff9f4e0f694f97a271ea56f48ae7a1">resize</a> (<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ac6d2a1348f013b1c42e5b0f141323290">size</a>)</td></tr>
<tr class="memdesc:a2cff9f4e0f694f97a271ea56f48ae7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the ring_buffer to the specified number of elements.  <a href="#a2cff9f4e0f694f97a271ea56f48ae7a1">More...</a><br /></td></tr>
<tr class="separator:a2cff9f4e0f694f97a271ea56f48ae7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51021a186204537d626aeb4e7d3f87e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aa51021a186204537d626aeb4e7d3f87e">clear</a> ()</td></tr>
<tr class="separator:aa51021a186204537d626aeb4e7d3f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d38850a2248033e19e99dcd7ae241a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a90d38850a2248033e19e99dcd7ae241a">begin</a> () noexcept</td></tr>
<tr class="memdesc:a90d38850a2248033e19e99dcd7ae241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read/write iterator that points to the first element in the ring_buffer.  <a href="#a90d38850a2248033e19e99dcd7ae241a">More...</a><br /></td></tr>
<tr class="separator:a90d38850a2248033e19e99dcd7ae241a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eb62e30c7ce15cb2051c3ac5d5fe7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a16eb62e30c7ce15cb2051c3ac5d5fe7a">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a16eb62e30c7ce15cb2051c3ac5d5fe7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the first element in the ring_buffer.  <a href="#a16eb62e30c7ce15cb2051c3ac5d5fe7a">More...</a><br /></td></tr>
<tr class="separator:a16eb62e30c7ce15cb2051c3ac5d5fe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7678a4bead24ce719daa89a8c618c42c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7678a4bead24ce719daa89a8c618c42c">end</a> () noexcept</td></tr>
<tr class="memdesc:a7678a4bead24ce719daa89a8c618c42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read/write iterator that points to the last element in the ring_buffer.  <a href="#a7678a4bead24ce719daa89a8c618c42c">More...</a><br /></td></tr>
<tr class="separator:a7678a4bead24ce719daa89a8c618c42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3797c03b0ca8a766eb4d78b8f9934d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a3797c03b0ca8a766eb4d78b8f9934d0e">end</a> () const noexcept</td></tr>
<tr class="memdesc:a3797c03b0ca8a766eb4d78b8f9934d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the last element in the ring_buffer.  <a href="#a3797c03b0ca8a766eb4d78b8f9934d0e">More...</a><br /></td></tr>
<tr class="separator:a3797c03b0ca8a766eb4d78b8f9934d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f9b7bd6089371f8385796d4af10310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a93cedf5ca13879c92db08307f88d990d">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ac4f9b7bd6089371f8385796d4af10310">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:ac4f9b7bd6089371f8385796d4af10310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read/write iterator that points to the first element in the ring_buffer.  <a href="#ac4f9b7bd6089371f8385796d4af10310">More...</a><br /></td></tr>
<tr class="separator:ac4f9b7bd6089371f8385796d4af10310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa226bafe9f6f0dfcd260d8307f08b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aaa226bafe9f6f0dfcd260d8307f08b0e">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aaa226bafe9f6f0dfcd260d8307f08b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the first element in the ring_buffer.  <a href="#aaa226bafe9f6f0dfcd260d8307f08b0e">More...</a><br /></td></tr>
<tr class="separator:aaa226bafe9f6f0dfcd260d8307f08b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b544bcc564e9098f8ea555e48add092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a93cedf5ca13879c92db08307f88d990d">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a4b544bcc564e9098f8ea555e48add092">rend</a> () noexcept</td></tr>
<tr class="memdesc:a4b544bcc564e9098f8ea555e48add092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read/write iterator that points to the last element in the ring_buffer.  <a href="#a4b544bcc564e9098f8ea555e48add092">More...</a><br /></td></tr>
<tr class="separator:a4b544bcc564e9098f8ea555e48add092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b6f2b757b6f9356cb4954bd749c661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a65b6f2b757b6f9356cb4954bd749c661">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a65b6f2b757b6f9356cb4954bd749c661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the last element in the ring_buffer.  <a href="#a65b6f2b757b6f9356cb4954bd749c661">More...</a><br /></td></tr>
<tr class="separator:a65b6f2b757b6f9356cb4954bd749c661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aff658defc5e597088e0291d2a8119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#af2aff658defc5e597088e0291d2a8119">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:af2aff658defc5e597088e0291d2a8119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the first element in the ring_buffer.  <a href="#af2aff658defc5e597088e0291d2a8119">More...</a><br /></td></tr>
<tr class="separator:af2aff658defc5e597088e0291d2a8119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e1de4a3cf8f87c95d50bb1d413cebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a74e1de4a3cf8f87c95d50bb1d413cebb">cend</a> () noexcept</td></tr>
<tr class="memdesc:a74e1de4a3cf8f87c95d50bb1d413cebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only te iterator that points to the last element in the ring_buffer.  <a href="#a74e1de4a3cf8f87c95d50bb1d413cebb">More...</a><br /></td></tr>
<tr class="separator:a74e1de4a3cf8f87c95d50bb1d413cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d5f188b93e04faabcc2003f90128c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ad8d5f188b93e04faabcc2003f90128c0">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ad8d5f188b93e04faabcc2003f90128c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the first element in the ring_buffer.  <a href="#ad8d5f188b93e04faabcc2003f90128c0">More...</a><br /></td></tr>
<tr class="separator:ad8d5f188b93e04faabcc2003f90128c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe84fcf652743042ef12875276cfb76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#afe84fcf652743042ef12875276cfb76f">crend</a> () const noexcept</td></tr>
<tr class="memdesc:afe84fcf652743042ef12875276cfb76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator that points to the last element in the ring_buffer.  <a href="#afe84fcf652743042ef12875276cfb76f">More...</a><br /></td></tr>
<tr class="separator:afe84fcf652743042ef12875276cfb76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2a1348f013b1c42e5b0f141323290"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ac6d2a1348f013b1c42e5b0f141323290">size</a> () const</td></tr>
<tr class="memdesc:ac6d2a1348f013b1c42e5b0f141323290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the ring_buffer.  <a href="#ac6d2a1348f013b1c42e5b0f141323290">More...</a><br /></td></tr>
<tr class="separator:ac6d2a1348f013b1c42e5b0f141323290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3162adf64f93f524d83443443f36c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8d3162adf64f93f524d83443443f36c4">max_size</a> () const</td></tr>
<tr class="separator:a8d3162adf64f93f524d83443443f36c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad436a234f153d01c8bf49c8c69deaa85"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ad436a234f153d01c8bf49c8c69deaa85">empty</a> () const</td></tr>
<tr class="separator:ad436a234f153d01c8bf49c8c69deaa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cc5d954673fad138154093cd1771a4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a18cc5d954673fad138154093cd1771a4">full</a> () const</td></tr>
<tr class="separator:a18cc5d954673fad138154093cd1771a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3212be6384de9cadd47026714522ead"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#af3212be6384de9cadd47026714522ead">capacity</a> () const</td></tr>
<tr class="separator:af3212be6384de9cadd47026714522ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7def11923cda7a1fe608a64dfbc61f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a6b7def11923cda7a1fe608a64dfbc61f">operator[]</a> (std::size_t i)</td></tr>
<tr class="memdesc:a6b7def11923cda7a1fe608a64dfbc61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in the ring_buffer.  <a href="#a6b7def11923cda7a1fe608a64dfbc61f">More...</a><br /></td></tr>
<tr class="separator:a6b7def11923cda7a1fe608a64dfbc61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d9ab2a18a064d69adee591d793869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a083d9ab2a18a064d69adee591d793869">operator[]</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a083d9ab2a18a064d69adee591d793869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in the ring_buffer.  <a href="#a083d9ab2a18a064d69adee591d793869">More...</a><br /></td></tr>
<tr class="separator:a083d9ab2a18a064d69adee591d793869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5780178be108f6e616bde6dfe7f1718b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a5780178be108f6e616bde6dfe7f1718b">at</a> (std::size_t i)</td></tr>
<tr class="memdesc:a5780178be108f6e616bde6dfe7f1718b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the data contained in the ring_buffer.  <a href="#a5780178be108f6e616bde6dfe7f1718b">More...</a><br /></td></tr>
<tr class="separator:a5780178be108f6e616bde6dfe7f1718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7cefc8bf6c0ace441ba39e65043771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#afd7cefc8bf6c0ace441ba39e65043771">at</a> (std::size_t i) const</td></tr>
<tr class="memdesc:afd7cefc8bf6c0ace441ba39e65043771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the data contained in the ring_buffer.  <a href="#afd7cefc8bf6c0ace441ba39e65043771">More...</a><br /></td></tr>
<tr class="separator:afd7cefc8bf6c0ace441ba39e65043771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6900e8410e31f505ef4dfb54fe3d7ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ac6900e8410e31f505ef4dfb54fe3d7ca">front</a> ()</td></tr>
<tr class="memdesc:ac6900e8410e31f505ef4dfb54fe3d7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read/write reference to the data at the first element of the ring_buffer.  <a href="#ac6900e8410e31f505ef4dfb54fe3d7ca">More...</a><br /></td></tr>
<tr class="separator:ac6900e8410e31f505ef4dfb54fe3d7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d542931ee67c6b60632065cabbd51b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7d542931ee67c6b60632065cabbd51b9">front</a> () const</td></tr>
<tr class="memdesc:a7d542931ee67c6b60632065cabbd51b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the data at the first element of the ring_buffer.  <a href="#a7d542931ee67c6b60632065cabbd51b9">More...</a><br /></td></tr>
<tr class="separator:a7d542931ee67c6b60632065cabbd51b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab67501628f89269021a6624d09c939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#afab67501628f89269021a6624d09c939">back</a> ()</td></tr>
<tr class="memdesc:afab67501628f89269021a6624d09c939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read/write reference to the data at the last element of the ring_buffer.  <a href="#afab67501628f89269021a6624d09c939">More...</a><br /></td></tr>
<tr class="separator:afab67501628f89269021a6624d09c939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f605548fea35dcec05f375e3a016c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#af98f605548fea35dcec05f375e3a016c">back</a> () const</td></tr>
<tr class="memdesc:af98f605548fea35dcec05f375e3a016c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the data at the last element of the ring_buffer.  <a href="#af98f605548fea35dcec05f375e3a016c">More...</a><br /></td></tr>
<tr class="separator:af98f605548fea35dcec05f375e3a016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666393be53e1e51475beac903c6f47d2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a666393be53e1e51475beac903c6f47d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a666393be53e1e51475beac903c6f47d2">emplace_back</a> (Args... arg)</td></tr>
<tr class="memdesc:a666393be53e1e51475beac903c6f47d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an object at the end of the ring_buffer.  <a href="#a666393be53e1e51475beac903c6f47d2">More...</a><br /></td></tr>
<tr class="separator:a666393be53e1e51475beac903c6f47d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c7305d1d634ea7ee488dd785401f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a320c7305d1d634ea7ee488dd785401f6">push_back</a> (const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a> &amp;item)</td></tr>
<tr class="memdesc:a320c7305d1d634ea7ee488dd785401f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the ring_buffer.  <a href="#a320c7305d1d634ea7ee488dd785401f6">More...</a><br /></td></tr>
<tr class="separator:a320c7305d1d634ea7ee488dd785401f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fdd78e992c7bc82b78810fc0a39d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aa4fdd78e992c7bc82b78810fc0a39d63">pop_front</a> ()</td></tr>
<tr class="memdesc:aa4fdd78e992c7bc82b78810fc0a39d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the ring.  <a href="#aa4fdd78e992c7bc82b78810fc0a39d63">More...</a><br /></td></tr>
<tr class="separator:aa4fdd78e992c7bc82b78810fc0a39d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ce618b155923f0e86b059f46609fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#acc3ce618b155923f0e86b059f46609fb">pop_back</a> ()</td></tr>
<tr class="memdesc:acc3ce618b155923f0e86b059f46609fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a>.  <a href="#acc3ce618b155923f0e86b059f46609fb">More...</a><br /></td></tr>
<tr class="separator:acc3ce618b155923f0e86b059f46609fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;<br />
class edsp::ring_buffer&lt; T, Allocator &gt;</h3>

<p>This class implements a ring buffer, also called circular buffer. </p>
<p>The term ring buffer refers to an area in memory which is used to store incoming data. When the buffer is filled, new data is written starting at the beginning of the buffer and overwriting the old.</p>
<p>The <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a> is a STL compliant container. It supports random access iterators, constant time insert and erase operations at the beginning or the end of the buffer and interoperability with std algorithms.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of element. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Allocator type, defaults to std::allocator&lt;T&gt;. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab6f1bee8a818f2725943f6b364c0098b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f1bee8a818f2725943f6b364c0098b">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ring_buffer_iterator&lt;const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2523b1d2013263f0f589d5f1220ce01d">self_type</a>, const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">self_type::value_type</a>&gt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44087c46078636ab5ee16595b457e786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44087c46078636ab5ee16595b457e786">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a44087c46078636ab5ee16595b457e786">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b016c118ea98b53a8eafd0a7855d0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b016c118ea98b53a8eafd0a7855d0ee">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a>&amp; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bcac877a56b406de8f1ad652ac7e804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcac877a56b406de8f1ad652ac7e804">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a>&gt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ec1e0e45087ccf97ff5e0841145dd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec1e0e45087ccf97ff5e0841145dd5f">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a0ec1e0e45087ccf97ff5e0841145dd5f">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2312e1d4e8f22847b27eeac8e5cba407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2312e1d4e8f22847b27eeac8e5cba407">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ring_buffer_iterator&lt;<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2523b1d2013263f0f589d5f1220ce01d">self_type</a>, <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">self_type::value_type</a>&gt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4de351caca02e8c1d6ddc45e7a8bc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4de351caca02e8c1d6ddc45e7a8bc7c">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aa4de351caca02e8c1d6ddc45e7a8bc7c">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a760fd3853f380e85672538d23a8a87ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760fd3853f380e85672538d23a8a87ee">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a>&amp; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93cedf5ca13879c92db08307f88d990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cedf5ca13879c92db08307f88d990d">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a>&gt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a93cedf5ca13879c92db08307f88d990d">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2523b1d2013263f0f589d5f1220ce01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2523b1d2013263f0f589d5f1220ce01d">&#9670;&nbsp;</a></span>self_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&lt;T, Allocator&gt; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2523b1d2013263f0f589d5f1220ce01d">self_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a716804d010b751e34cf81d0ed50add90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716804d010b751e34cf81d0ed50add90">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50952d1ad4089381fdf10144bb3596ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50952d1ad4089381fdf10144bb3596ec">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab7e9b02afa103ec956e0763920f24431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e9b02afa103ec956e0763920f24431">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56b1a22304e17f6f4a0fe6707ae2285d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b1a22304e17f6f4a0fe6707ae2285d">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a589a0bb51b1d1c64e8bfb0f0698e28ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589a0bb51b1d1c64e8bfb0f0698e28ad">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a499ca20b37cffd8dc7a844e0753ea46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499ca20b37cffd8dc7a844e0753ea46a">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a ring_buffer with default constructed elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of elements to initially create.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the ring_buffer with N default constructed elements. </p>

</div>
</div>
<a id="a51fdbdf5cd8b357cb931cdb770a2c8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fdbdf5cd8b357cb931cdb770a2c8bf">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a ring_buffer with copies of an exemplar element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">value</td><td>An element to copy. This constructor fills the ring_buffer with N copies of value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6b8e0388bebf488edb3514809063cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b8e0388bebf488edb3514809063cc7">&#9670;&nbsp;</a></span>~ring_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::~<a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5780178be108f6e616bde6dfe7f1718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5780178be108f6e616bde6dfe7f1718b">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the ring_buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>__n</em> is an invalid index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails. </p>

</div>
</div>
<a id="afd7cefc8bf6c0ace441ba39e65043771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7cefc8bf6c0ace441ba39e65043771">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the ring_buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>__n</em> is an invalid index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails. </p>

</div>
</div>
<a id="afab67501628f89269021a6624d09c939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab67501628f89269021a6624d09c939">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write reference to the data at the last element of the ring_buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element in the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a>. </dd></dl>

</div>
</div>
<a id="af98f605548fea35dcec05f375e3a016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98f605548fea35dcec05f375e3a016c">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the data at the last element of the ring_buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element in the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a>. </dd></dl>

</div>
</div>
<a id="a90d38850a2248033e19e99dcd7ae241a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d38850a2248033e19e99dcd7ae241a">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator that points to the first element in the ring_buffer. </p>
<p>Iteration is done in ordinary element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element. </dd></dl>

</div>
</div>
<a id="a16eb62e30c7ce15cb2051c3ac5d5fe7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16eb62e30c7ce15cb2051c3ac5d5fe7a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the first element in the ring_buffer. </p>
<p>Iteration is done in ordinary element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element. </dd></dl>

</div>
</div>
<a id="af3212be6384de9cadd47026714522ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3212be6384de9cadd47026714522ead">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of elements that the ring_buffer can hold. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements that the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a> can hold. </dd></dl>

</div>
</div>
<a id="af2aff658defc5e597088e0291d2a8119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2aff658defc5e597088e0291d2a8119">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the first element in the ring_buffer. </p>
<p>Iteration is done in ordinary element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element. </dd></dl>

</div>
</div>
<a id="a74e1de4a3cf8f87c95d50bb1d413cebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e1de4a3cf8f87c95d50bb1d413cebb">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only te iterator that points to the last element in the ring_buffer. </p>
<p>Iteration is done in ordinary element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last element. </dd></dl>

</div>
</div>
<a id="aa51021a186204537d626aeb4e7d3f87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51021a186204537d626aeb4e7d3f87e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a id="ad8d5f188b93e04faabcc2003f90128c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d5f188b93e04faabcc2003f90128c0">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the first element in the ring_buffer. </p>
<p>Iteration is done in reverse element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element. </dd></dl>

</div>
</div>
<a id="afe84fcf652743042ef12875276cfb76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe84fcf652743042ef12875276cfb76f">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the last element in the ring_buffer. </p>
<p>Iteration is done in reverse element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last element. </dd></dl>

</div>
</div>
<a id="a666393be53e1e51475beac903c6f47d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666393be53e1e51475beac903c6f47d2">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an object at the end of the ring_buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. </p>

</div>
</div>
<a id="ad436a234f153d01c8bf49c8c69deaa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad436a234f153d01c8bf49c8c69deaa85">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the ring_buffer is empty. </p><dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a> is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a7678a4bead24ce719daa89a8c618c42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7678a4bead24ce719daa89a8c618c42c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a2312e1d4e8f22847b27eeac8e5cba407">iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator that points to the last element in the ring_buffer. </p>
<p>Iteration is done in ordinary element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last element. </dd></dl>

</div>
</div>
<a id="a3797c03b0ca8a766eb4d78b8f9934d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3797c03b0ca8a766eb4d78b8f9934d0e">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ab6f1bee8a818f2725943f6b364c0098b">const_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the last element in the ring_buffer. </p>
<p>Iteration is done in ordinary element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last element. </dd></dl>

</div>
</div>
<a id="ac6900e8410e31f505ef4dfb54fe3d7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6900e8410e31f505ef4dfb54fe3d7ca">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write reference to the data at the first element of the ring_buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element in the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a>. </dd></dl>

</div>
</div>
<a id="a7d542931ee67c6b60632065cabbd51b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d542931ee67c6b60632065cabbd51b9">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the data at the first element of the ring_buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element in the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a>. </dd></dl>

</div>
</div>
<a id="a18cc5d954673fad138154093cd1771a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cc5d954673fad138154093cd1771a4">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the ring_buffer is full. </p><dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a> is full, false otherwise. </dd></dl>

</div>
</div>
<a id="a8d3162adf64f93f524d83443443f36c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3162adf64f93f524d83443443f36c4">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#ac6d2a1348f013b1c42e5b0f141323290" title="Returns the number of elements in the ring_buffer. ">size()</a> of the largest possible ring_buffer. </p><dl class="section return"><dt>Returns</dt><dd>Maximum allowed size. </dd></dl>

</div>
</div>
<a id="a1a67fe13baebbee4789aed21c295a0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a67fe13baebbee4789aed21c295a0f2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&amp; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ee88163fd7cd1b6c8fbcedd43a2913b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee88163fd7cd1b6c8fbcedd43a2913b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&amp; <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b7def11923cda7a1fe608a64dfbc61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7def11923cda7a1fe608a64dfbc61f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a760fd3853f380e85672538d23a8a87ee">reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the ring_buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a5780178be108f6e616bde6dfe7f1718b" title="Provides access to the data contained in the ring_buffer. ">at()</a>.) </p>

</div>
</div>
<a id="a083d9ab2a18a064d69adee591d793869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083d9ab2a18a064d69adee591d793869">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a7b016c118ea98b53a8eafd0a7855d0ee">const_reference</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the ring_buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a5780178be108f6e616bde6dfe7f1718b" title="Provides access to the data contained in the ring_buffer. ">at()</a>.) </p>

</div>
</div>
<a id="acc3ce618b155923f0e86b059f46609fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3ce618b155923f0e86b059f46609fb">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a>. </p>
<p>This is a typical stack operation.</p>
<p>Note that no data is returned, and if the first element's data is needed, it should be retrieved before <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aa4fdd78e992c7bc82b78810fc0a39d63" title="Removes the first element of the ring. ">pop_front()</a> is called. </p>

</div>
</div>
<a id="aa4fdd78e992c7bc82b78810fc0a39d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fdd78e992c7bc82b78810fc0a39d63">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element of the ring. </p>
<p>This is a typical stack operation.</p>
<p>Note that no data is returned, and if the first element's data is needed, it should be retrieved before <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#aa4fdd78e992c7bc82b78810fc0a39d63" title="Removes the first element of the ring. ">pop_front()</a> is called. </p>

</div>
</div>
<a id="a320c7305d1d634ea7ee488dd785401f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c7305d1d634ea7ee488dd785401f6">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a50952d1ad4089381fdf10144bb3596ec">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the ring_buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the end of the ring_buffer and assigns the given data to it. </p>

</div>
</div>
<a id="ac4f9b7bd6089371f8385796d4af10310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f9b7bd6089371f8385796d4af10310">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a93cedf5ca13879c92db08307f88d990d">reverse_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator that points to the first element in the ring_buffer. </p>
<p>Iteration is done in reverse element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element. </dd></dl>

</div>
</div>
<a id="aaa226bafe9f6f0dfcd260d8307f08b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa226bafe9f6f0dfcd260d8307f08b0e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the first element in the ring_buffer. </p>
<p>Iteration is done in reverse element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element. </dd></dl>

</div>
</div>
<a id="a4b544bcc564e9098f8ea555e48add092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b544bcc564e9098f8ea555e48add092">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a93cedf5ca13879c92db08307f88d990d">reverse_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator that points to the last element in the ring_buffer. </p>
<p>Iteration is done in reverse element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last element. </dd></dl>

</div>
</div>
<a id="a65b6f2b757b6f9356cb4954bd749c661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b6f2b757b6f9356cb4954bd749c661">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a8bcac877a56b406de8f1ad652ac7e804">const_reverse_iterator</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator that points to the last element in the ring_buffer. </p>
<p>Iteration is done in reverse element order. </p><dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last element. </dd></dl>

</div>
</div>
<a id="a2cff9f4e0f694f97a271ea56f48ae7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cff9f4e0f694f97a271ea56f48ae7a1">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the ring_buffer to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of elements the ring_buffer should contain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6d2a1348f013b1c42e5b0f141323290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d2a1348f013b1c42e5b0f141323290">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html#a716804d010b751e34cf81d0ed50add90">size_type</a> <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html">edsp::ring_buffer</a>&lt; T, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the ring_buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the <a class="el" href="../../d1/d1f/classedsp_1_1ring__buffer.html" title="This class implements a ring buffer, also called circular buffer. ">ring_buffer</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/<a class="el" href="../../d3/dcf/ring__buffer_8hpp_source.html">ring_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
